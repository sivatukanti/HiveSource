// 
// Decompiled by Procyon v0.5.36
// 

package com.jolbox.bonecp;

import org.slf4j.LoggerFactory;
import java.util.Iterator;
import java.sql.SQLException;
import com.google.common.collect.MapMaker;
import java.util.concurrent.ConcurrentMap;
import org.slf4j.Logger;

public class StatementCache implements IStatementCache
{
    private static final Logger logger;
    private ConcurrentMap<String, StatementHandle> cache;
    private int cacheSize;
    private final boolean maintainStats;
    private final Statistics statistics;
    
    public StatementCache(final int size, final boolean maintainStats, final Statistics statistics) {
        this.maintainStats = maintainStats;
        this.statistics = statistics;
        this.cache = new MapMaker().concurrencyLevel(32).makeMap();
        this.cacheSize = size;
    }
    
    public String calculateCacheKey(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        final StringBuilder tmp = this.calculateCacheKeyInternal(sql, resultSetType, resultSetConcurrency);
        tmp.append(", H:");
        tmp.append(resultSetHoldability);
        return tmp.toString();
    }
    
    public String calculateCacheKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
        final StringBuilder tmp = this.calculateCacheKeyInternal(sql, resultSetType, resultSetConcurrency);
        return tmp.toString();
    }
    
    private StringBuilder calculateCacheKeyInternal(final String sql, final int resultSetType, final int resultSetConcurrency) {
        final StringBuilder tmp = new StringBuilder(sql.length() + 20);
        tmp.append(sql);
        tmp.append(", T");
        tmp.append(resultSetType);
        tmp.append(", C");
        tmp.append(resultSetConcurrency);
        return tmp;
    }
    
    public String calculateCacheKey(final String sql, final int autoGeneratedKeys) {
        final StringBuilder tmp = new StringBuilder(sql.length() + 4);
        tmp.append(sql);
        tmp.append(autoGeneratedKeys);
        return tmp.toString();
    }
    
    public String calculateCacheKey(final String sql, final int[] columnIndexes) {
        final StringBuilder tmp = new StringBuilder(sql.length() + 4);
        tmp.append(sql);
        for (int i = 0; i < columnIndexes.length; ++i) {
            tmp.append(columnIndexes[i]);
            tmp.append("CI,");
        }
        return tmp.toString();
    }
    
    public String calculateCacheKey(final String sql, final String[] columnNames) {
        final StringBuilder tmp = new StringBuilder(sql.length() + 4);
        tmp.append(sql);
        for (int i = 0; i < columnNames.length; ++i) {
            tmp.append(columnNames[i]);
            tmp.append("CN,");
        }
        return tmp.toString();
    }
    
    public StatementHandle get(final String key) {
        StatementHandle statement = this.cache.get(key);
        if (statement != null && !statement.logicallyClosed.compareAndSet(true, false)) {
            statement = null;
        }
        if (this.maintainStats) {
            if (statement != null) {
                this.statistics.incrementCacheHits();
            }
            else {
                this.statistics.incrementCacheMiss();
            }
        }
        return statement;
    }
    
    public StatementHandle get(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        return this.get(this.calculateCacheKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
    }
    
    public StatementHandle get(final String sql, final int resultSetType, final int resultSetConcurrency) {
        return this.get(this.calculateCacheKey(sql, resultSetType, resultSetConcurrency));
    }
    
    public StatementHandle get(final String sql, final int autoGeneratedKeys) {
        return this.get(this.calculateCacheKey(sql, autoGeneratedKeys));
    }
    
    public StatementHandle get(final String sql, final int[] columnIndexes) {
        return this.get(this.calculateCacheKey(sql, columnIndexes));
    }
    
    public StatementHandle get(final String sql, final String[] columnNames) {
        return this.get(this.calculateCacheKey(sql, columnNames));
    }
    
    public int size() {
        return this.cache.size();
    }
    
    public void clear() {
        for (final StatementHandle statement : this.cache.values()) {
            try {
                if (statement.isClosed()) {
                    continue;
                }
                statement.close();
            }
            catch (SQLException ex) {}
        }
        this.cache.clear();
    }
    
    public void checkForProperClosure() {
        for (final StatementHandle statement : this.cache.values()) {
            if (!statement.isClosed()) {
                StatementCache.logger.error("Statement not closed properly in application\n\n" + statement.getOpenStackTrace());
            }
        }
    }
    
    public void putIfAbsent(final String key, final StatementHandle handle) {
        if (this.cache.size() < this.cacheSize && key != null && this.cache.putIfAbsent(key, handle) == null) {
            handle.inCache = true;
            if (this.maintainStats) {
                this.statistics.incrementStatementsCached();
            }
        }
    }
    
    static {
        logger = LoggerFactory.getLogger(StatementCache.class);
    }
}
