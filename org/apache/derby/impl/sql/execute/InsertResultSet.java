// 
// Decompiled by Procyon v0.5.36
// 

package org.apache.derby.impl.sql.execute;

import org.apache.derby.iapi.sql.dictionary.TupleDescriptor;
import org.apache.derby.catalog.Statistics;
import org.apache.derby.iapi.sql.dictionary.StatisticsDescriptor;
import org.apache.derby.catalog.types.StatisticsImpl;
import org.apache.derby.catalog.UUID;
import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
import org.apache.derby.iapi.store.access.SortObserver;
import org.apache.derby.iapi.store.access.GroupFetchScanController;
import org.apache.derby.iapi.sql.StatementUtil;
import org.apache.derby.iapi.store.access.Qualifier;
import org.apache.derby.iapi.services.context.ContextManager;
import java.util.Enumeration;
import org.apache.derby.iapi.sql.depend.Provider;
import org.apache.derby.iapi.types.DataValueDescriptor;
import java.util.Vector;
import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
import java.util.Properties;
import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
import org.apache.derby.iapi.util.StringUtil;
import org.apache.derby.iapi.sql.Activation;
import org.apache.derby.iapi.sql.execute.CursorResultSet;
import org.apache.derby.iapi.error.StandardException;
import org.apache.derby.iapi.services.io.StreamStorable;
import org.apache.derby.iapi.types.NumberDataValue;
import org.apache.derby.iapi.types.RowLocation;
import org.apache.derby.iapi.store.access.SortController;
import org.apache.derby.iapi.store.access.ColumnOrdering;
import org.apache.derby.iapi.store.access.ScanController;
import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
import org.apache.derby.iapi.sql.execute.ExecIndexRow;
import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
import org.apache.derby.iapi.sql.dictionary.DataDictionary;
import org.apache.derby.iapi.store.access.ConglomerateController;
import org.apache.derby.iapi.services.io.FormatableBitSet;
import java.util.Hashtable;
import org.apache.derby.iapi.sql.execute.ExecRow;
import org.apache.derby.iapi.store.access.TransactionController;
import org.apache.derby.iapi.sql.execute.RowChanger;
import org.apache.derby.iapi.sql.ResultDescription;
import org.apache.derby.iapi.sql.ResultSet;
import org.apache.derby.iapi.services.loader.GeneratedMethod;
import org.apache.derby.iapi.sql.execute.NoPutResultSet;
import org.apache.derby.iapi.sql.execute.TargetResultSet;

class InsertResultSet extends DMLWriteResultSet implements TargetResultSet
{
    private NoPutResultSet sourceResultSet;
    NoPutResultSet savedSource;
    InsertConstantAction constants;
    private GeneratedMethod generationClauses;
    private GeneratedMethod checkGM;
    private long heapConglom;
    private ResultSet autoGeneratedKeysResultSet;
    private TemporaryRowHolderImpl autoGeneratedKeysRowsHolder;
    private int[] autoGeneratedKeysColumnIndexes;
    private ResultDescription resultDescription;
    private RowChanger rowChanger;
    private TransactionController tc;
    private ExecRow row;
    boolean userSpecifiedBulkInsert;
    boolean bulkInsertPerformed;
    protected boolean bulkInsert;
    private boolean bulkInsertReplace;
    private boolean firstRow;
    private boolean[] needToDropSort;
    private Hashtable indexConversionTable;
    private FormatableBitSet indexedCols;
    private ConglomerateController bulkHeapCC;
    protected DataDictionary dd;
    protected TableDescriptor td;
    private ExecIndexRow[] indexRows;
    private final int fullTemplateId;
    private long[] sortIds;
    private RowLocationRetRowSource[] rowSources;
    private ScanController bulkHeapSC;
    private ColumnOrdering[][] ordering;
    private int[][] collation;
    private SortController[] sorters;
    private TemporaryRowHolderImpl rowHolder;
    private RowLocation rl;
    private boolean hasBeforeStatementTrigger;
    private boolean hasBeforeRowTrigger;
    private BulkTableScanResultSet tableScan;
    private int numOpens;
    private boolean firstExecute;
    private FKInfo[] fkInfoArray;
    private TriggerInfo triggerInfo;
    private RISetChecker fkChecker;
    private TriggerEventActivator triggerActivator;
    private NumberDataValue[] aiCache;
    protected boolean autoincrementGenerated;
    private long identityVal;
    private boolean setIdentity;
    
    public ResultDescription getResultDescription() {
        return this.resultDescription;
    }
    
    public void changedRow(final ExecRow execRow, final RowLocation rowLocation) throws StandardException {
        if (this.constants.irgs.length > 0) {
            final RowLocation rowLocation2 = (RowLocation)rowLocation.cloneValue(false);
            for (int i = 0; i < execRow.getRowArray().length; ++i) {
                if (this.constants.indexedCols[i]) {
                    if (execRow.getRowArray()[i] instanceof StreamStorable) {
                        execRow.getRowArray()[i].getObject();
                    }
                }
            }
            if (this.firstRow) {
                this.firstRow = false;
                this.indexRows = new ExecIndexRow[this.constants.irgs.length];
                this.setUpAllSorts(execRow.getNewNullRow(), rowLocation2);
            }
            for (int j = 0; j < this.constants.irgs.length; ++j) {
                this.indexRows[j].getNewObjectArray();
                this.constants.irgs[j].getIndexRow(execRow, rowLocation2, this.indexRows[j], null);
                this.sorters[j].insert(this.indexRows[j].getRowArray());
            }
        }
    }
    
    public ExecRow preprocessSourceRow(final ExecRow execRow) throws StandardException {
        if (this.hasBeforeRowTrigger) {
            this.rowHolder.truncate();
            this.rowHolder.insert(execRow);
            this.triggerActivator.notifyEvent(TriggerEvents.BEFORE_INSERT, null, this.rowHolder.getResultSet(), null);
        }
        if (this.generationClauses != null) {
            this.evaluateGenerationClauses(this.generationClauses, this.activation, this.sourceResultSet, execRow, false);
        }
        if (this.checkGM != null && !this.hasBeforeStatementTrigger) {
            this.evaluateCheckConstraints();
        }
        if (this.constants.irgs.length > 0) {
            return execRow.getClone(this.indexedCols);
        }
        return execRow;
    }
    
    private void evaluateCheckConstraints() throws StandardException {
        if (this.checkGM != null) {
            this.checkGM.invoke(this.activation);
        }
    }
    
    InsertResultSet(final NoPutResultSet sourceResultSet, final GeneratedMethod generationClauses, final GeneratedMethod checkGM, final int fullTemplateId, final Activation activation) throws StandardException {
        super(activation);
        this.firstRow = true;
        this.sourceResultSet = sourceResultSet;
        this.constants = (InsertConstantAction)this.constantAction;
        this.generationClauses = generationClauses;
        this.checkGM = checkGM;
        this.fullTemplateId = fullTemplateId;
        this.heapConglom = this.constants.conglomId;
        this.tc = activation.getTransactionController();
        this.fkInfoArray = this.constants.getFKInfo();
        this.triggerInfo = this.constants.getTriggerInfo();
        this.hasBeforeStatementTrigger = (this.triggerInfo != null && this.triggerInfo.hasTrigger(true, false));
        this.hasBeforeRowTrigger = (this.triggerInfo != null && this.triggerInfo.hasTrigger(true, true));
        this.resultDescription = this.sourceResultSet.getResultDescription();
        final String property = this.constants.getProperty("insertMode");
        final RowLocation[] autoincRowLocation;
        if ((autoincRowLocation = this.constants.getAutoincRowLocation()) != null) {
            this.aiCache = new NumberDataValue[autoincRowLocation.length];
            for (int i = 0; i < this.resultDescription.getColumnCount(); ++i) {
                if (autoincRowLocation[i] != null) {
                    this.aiCache[i] = (NumberDataValue)this.resultDescription.getColumnDescriptor(i + 1).getType().getNull();
                }
            }
        }
        if (property != null) {
            if (StringUtil.SQLEqualsIgnoreCase(property, "BULKINSERT")) {
                this.userSpecifiedBulkInsert = true;
            }
            else if (StringUtil.SQLEqualsIgnoreCase(property, "REPLACE")) {
                this.userSpecifiedBulkInsert = true;
                this.bulkInsertReplace = true;
                this.bulkInsert = true;
                if (this.triggerInfo != null) {
                    throw StandardException.newException("X0Y72.S", this.constants.getTableName(), this.triggerInfo.getTriggerArray()[0].getName());
                }
            }
        }
    }
    
    public void open() throws StandardException {
        this.setup();
        this.firstExecute = (this.rowChanger == null);
        this.autoincrementGenerated = false;
        this.dd = this.lcc.getDataDictionary();
        if (this.activation.getAutoGeneratedKeysResultsetMode()) {
            if (this.activation.getAutoGeneratedKeysColumnIndexes() != null) {
                this.verifyAutoGeneratedColumnsIndexes(this.activation.getAutoGeneratedKeysColumnIndexes());
            }
            else if (this.activation.getAutoGeneratedKeysColumnNames() != null) {
                this.verifyAutoGeneratedColumnsNames(this.activation.getAutoGeneratedKeysColumnNames());
            }
        }
        this.rowCount = 0L;
        if (this.numOpens++ == 0) {
            this.sourceResultSet.openCore();
        }
        else {
            this.sourceResultSet.reopenCore();
        }
        if (this.userSpecifiedBulkInsert) {
            if (!this.bulkInsertReplace) {
                this.bulkInsert = this.verifyBulkInsert();
            }
            else {
                this.getExclusiveTableLock();
            }
        }
        if (this.bulkInsert) {
            this.sourceResultSet.setTargetResultSet(this);
            final ExecRow build = ((ExecRowBuilder)this.activation.getPreparedStatement().getSavedObject(this.fullTemplateId)).build(this.activation.getExecutionFactory());
            final long bulkInsertCore = this.bulkInsertCore(this.lcc, build, this.heapConglom);
            if (this.hasBeforeStatementTrigger) {
                this.tableScan = this.getTableScanResultSet(bulkInsertCore);
                this.triggerActivator.notifyEvent(TriggerEvents.BEFORE_INSERT, null, this.tableScan, null);
                if (this.checkGM != null || this.generationClauses != null) {
                    this.tableScan = this.getTableScanResultSet(bulkInsertCore);
                    try {
                        ExecRow nextRowCore;
                        while ((nextRowCore = this.tableScan.getNextRowCore()) != null) {
                            this.sourceResultSet.setCurrentRow(nextRowCore);
                            this.evaluateCheckConstraints();
                        }
                    }
                    finally {
                        this.sourceResultSet.clearCurrentRow();
                    }
                }
            }
            this.bulkValidateForeignKeys(this.tc, this.lcc.getContextManager(), build);
            if (this.triggerInfo != null && (this.triggerInfo.hasTrigger(false, true) || this.triggerInfo.hasTrigger(false, false))) {
                this.triggerActivator.notifyEvent(TriggerEvents.AFTER_INSERT, null, this.getTableScanResultSet(bulkInsertCore), null);
            }
            this.bulkInsertPerformed = true;
        }
        else {
            this.row = this.getNextRowCore(this.sourceResultSet);
            this.normalInsertCore(this.lcc, this.firstExecute);
        }
        if (this.lcc.getRunTimeStatisticsMode()) {
            this.savedSource = this.sourceResultSet;
        }
        if (this.activation.getAutoGeneratedKeysResultsetMode()) {
            this.autoGeneratedKeysResultSet = this.autoGeneratedKeysRowsHolder.getResultSet();
        }
        else {
            this.autoGeneratedKeysResultSet = null;
        }
        this.cleanUp();
        if (this.aiCache != null) {
            final HashMap<String, Long> hashMap = new HashMap<String, Long>();
            for (int length = this.aiCache.length, i = 0; i < length; ++i) {
                if (this.aiCache[i] != null) {
                    hashMap.put(AutoincrementCounter.makeIdentity(this.constants.getSchemaName(), this.constants.getTableName(), this.constants.getColumnName(i)), new Long(this.aiCache[i].getLong()));
                }
            }
            final InternalTriggerExecutionContext internalTriggerExecutionContext = (InternalTriggerExecutionContext)this.lcc.getTriggerExecutionContext();
            if (internalTriggerExecutionContext == null) {
                this.lcc.copyHashtableToAIHT(hashMap);
            }
            else {
                internalTriggerExecutionContext.copyHashtableToAIHT(hashMap);
            }
        }
        this.endTime = this.getCurrentTimeMillis();
    }
    
    public void close() throws StandardException {
        super.close();
        if (this.autoGeneratedKeysRowsHolder != null) {
            this.autoGeneratedKeysRowsHolder.close();
        }
    }
    
    private void verifyAutoGeneratedColumnsIndexes(final int[] array) throws StandardException {
        final int length = array.length;
        final TableDescriptor tableDescriptor = this.dd.getTableDescriptor(this.constants.targetUUID);
        for (int i = 0; i < length; ++i) {
            if (!this.verifyAutoGenColumn(tableDescriptor.getColumnDescriptor(array[i]))) {
                throw StandardException.newException("X0X0E.S", new Integer(array[i]), tableDescriptor.getName());
            }
        }
    }
    
    private int[] generatedColumnPositionsArray() throws StandardException {
        final TableDescriptor tableDescriptor = this.dd.getTableDescriptor(this.constants.targetUUID);
        final int maxColumnID = tableDescriptor.getMaxColumnID();
        final int[] a = new int[maxColumnID];
        Arrays.fill(a, -1);
        int n = 0;
        for (int i = 0; i < maxColumnID; ++i) {
            final ColumnDescriptor columnDescriptor = tableDescriptor.getColumnDescriptor(i + 1);
            if (columnDescriptor.isAutoincrement()) {
                ++n;
                a[i] = i + 1;
            }
            else if (columnDescriptor.getDefaultValue() != null || columnDescriptor.getDefaultInfo() != null) {
                ++n;
                a[i] = i + 1;
            }
        }
        final int[] array = new int[n];
        int j = 0;
        int n2 = 0;
        while (j < maxColumnID) {
            if (a[j] != -1) {
                array[n2++] = a[j];
            }
            ++j;
        }
        return array;
    }
    
    private int[] uniqueColumnPositionArray(final int[] array) throws StandardException {
        final int length = array.length;
        final int[] array2 = new int[this.dd.getTableDescriptor(this.constants.targetUUID).getMaxColumnID()];
        int n = 0;
        for (int i = 0; i < length; ++i) {
            if (array2[array[i] - 1] == 0) {
                ++n;
                array2[array[i] - 1] = array[i];
            }
        }
        final int[] array3 = new int[n];
        int j = 0;
        int n2 = 0;
        while (j < array2.length) {
            if (array2[j] != 0) {
                array3[n2++] = array2[j];
            }
            ++j;
        }
        return array3;
    }
    
    private void verifyAutoGeneratedColumnsNames(final String[] array) throws StandardException {
        final int length = array.length;
        final int[] array2 = new int[length];
        final TableDescriptor tableDescriptor = this.dd.getTableDescriptor(this.constants.targetUUID);
        for (int i = 0; i < length; ++i) {
            if (array[i] == null) {
                throw StandardException.newException("X0X0F.S", array[i], tableDescriptor.getName());
            }
            final ColumnDescriptor columnDescriptor = tableDescriptor.getColumnDescriptor(array[i]);
            if (!this.verifyAutoGenColumn(columnDescriptor)) {
                throw StandardException.newException("X0X0F.S", array[i], tableDescriptor.getName());
            }
            array2[i] = columnDescriptor.getPosition();
        }
        this.activation.setAutoGeneratedKeysResultsetInfo(array2, null);
    }
    
    private boolean verifyAutoGenColumn(final ColumnDescriptor columnDescriptor) {
        return columnDescriptor != null && columnDescriptor.isAutoincrement();
    }
    
    public ResultSet getAutoGeneratedKeysResultset() {
        return this.autoGeneratedKeysResultSet;
    }
    
    public NumberDataValue getSetAutoincrementValue(final int n, final long n2) throws StandardException {
        final int n3 = n - 1;
        this.setIdentity = (!this.autoincrementGenerated && this.isSourceRowResultSet());
        this.autoincrementGenerated = true;
        if (this.bulkInsert) {
            final ColumnDescriptor columnDescriptor = this.td.getColumnDescriptor(n);
            if (this.aiCache[n3].isNull()) {
                long value;
                if (this.bulkInsertReplace) {
                    value = columnDescriptor.getAutoincStart();
                }
                else {
                    value = this.dd.getSetAutoincrementValue(this.constants.autoincRowLocation[n3], this.tc, false, this.aiCache[n3], true).getLong();
                }
                this.lcc.autoincrementCreateCounter(this.td.getSchemaName(), this.td.getName(), columnDescriptor.getColumnName(), new Long(value), n2, n);
            }
            this.aiCache[n - 1].setValue(this.lcc.nextAutoincrementValue(this.td.getSchemaName(), this.td.getName(), columnDescriptor.getColumnName()));
        }
        else {
            TransactionController transactionController = null;
            final TransactionController tc = this.tc;
            TransactionController transactionController2;
            try {
                transactionController = (transactionController2 = this.tc.startNestedUserTransaction(false, false));
            }
            catch (StandardException ex2) {
                transactionController2 = this.tc;
            }
            NumberDataValue numberDataValue;
            try {
                numberDataValue = this.dd.getSetAutoincrementValue(this.constants.autoincRowLocation[n3], transactionController2, true, this.aiCache[n3], transactionController2 == this.tc);
            }
            catch (StandardException ex) {
                if (transactionController2 == this.tc) {
                    throw ex;
                }
                if (ex.getMessageId().equals("40XL1")) {
                    numberDataValue = this.dd.getSetAutoincrementValue(this.constants.autoincRowLocation[n3], this.tc, true, this.aiCache[n3], true);
                }
                else {
                    if (ex.getMessageId().equals("22003")) {
                        throw StandardException.newException("42Z24", ex, this.constants.getTableName(), this.constants.getColumnName(n3));
                    }
                    throw ex;
                }
            }
            finally {
                if (transactionController != null) {
                    transactionController.commitNoSync(1);
                    transactionController.destroy();
                }
            }
            this.aiCache[n3] = numberDataValue;
            if (this.setIdentity) {
                this.identityVal = numberDataValue.getLong();
            }
        }
        return this.aiCache[n3];
    }
    
    private boolean isSourceRowResultSet() {
        boolean b = false;
        if (this.sourceResultSet instanceof NormalizeResultSet) {
            b = (((NormalizeResultSet)this.sourceResultSet).source instanceof RowResultSet);
        }
        return b;
    }
    
    private boolean isSingleRowResultSet() {
        boolean b = false;
        if (this.sourceResultSet instanceof RowResultSet) {
            b = true;
        }
        else if (this.sourceResultSet instanceof NormalizeResultSet) {
            b = (((NormalizeResultSet)this.sourceResultSet).source instanceof RowResultSet);
        }
        return b;
    }
    
    private void normalInsertCore(final LanguageConnectionContext languageConnectionContext, final boolean b) throws StandardException {
        final boolean b2 = this.constants.hasAutoincrement() && this.isSingleRowResultSet();
        long long1 = 0L;
        if (b) {
            (this.rowChanger = languageConnectionContext.getLanguageConnectionFactory().getExecutionFactory().getRowChanger(this.heapConglom, this.constants.heapSCOCI, this.heapDCOCI, this.constants.irgs, this.constants.indexCIDS, this.constants.indexSCOCIs, this.indexDCOCIs, 0, this.tc, null, this.constants.getStreamStorableHeapColIds(), this.activation)).setIndexNames(this.constants.indexNames);
        }
        this.rowChanger.open(this.decodeLockMode(this.constants.lockMode));
        if (this.constants.deferred) {
            this.activation.clearIndexScanInfo();
        }
        if (this.fkInfoArray != null) {
            if (this.fkChecker == null) {
                this.fkChecker = new RISetChecker(this.tc, this.fkInfoArray);
            }
            else {
                this.fkChecker.reopen();
            }
        }
        if (b && this.constants.deferred) {
            final Properties properties = new Properties();
            this.rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties);
            this.rowHolder = new TemporaryRowHolderImpl(this.activation, properties, this.resultDescription);
            this.rowChanger.setRowHolder(this.rowHolder);
        }
        if (b && this.activation.getAutoGeneratedKeysResultsetMode()) {
            final Properties properties2 = new Properties();
            this.autoGeneratedKeysColumnIndexes = this.activation.getAutoGeneratedKeysColumnIndexes();
            this.rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties2);
            if (this.autoGeneratedKeysColumnIndexes != null) {
                this.autoGeneratedKeysColumnIndexes = this.uniqueColumnPositionArray(this.autoGeneratedKeysColumnIndexes);
            }
            else {
                this.autoGeneratedKeysColumnIndexes = this.generatedColumnPositionsArray();
            }
            this.autoGeneratedKeysRowsHolder = new TemporaryRowHolderImpl(this.activation, properties2, languageConnectionContext.getLanguageFactory().getResultDescription(this.resultDescription, this.autoGeneratedKeysColumnIndexes));
        }
        while (this.row != null) {
            if (this.activation.getAutoGeneratedKeysResultsetMode() && this.autoGeneratedKeysColumnIndexes.length > 0) {
                this.autoGeneratedKeysRowsHolder.insert(this.getCompactRow(this.row, this.autoGeneratedKeysColumnIndexes));
            }
            this.evaluateGenerationClauses(this.generationClauses, this.activation, this.sourceResultSet, this.row, false);
            if (this.constants.deferred) {
                this.rowHolder.insert(this.row);
            }
            else {
                this.evaluateCheckConstraints();
                if (this.fkChecker != null) {
                    this.fkChecker.doFKCheck(this.row);
                }
                if (this.constants.irgs.length > 0) {
                    final DataValueDescriptor[] rowArray = this.row.getRowArray();
                    for (int i = 0; i < rowArray.length; ++i) {
                        if (this.constants.indexedCols[i]) {
                            if (rowArray[i] instanceof StreamStorable) {
                                rowArray[i].getObject();
                            }
                        }
                    }
                }
                this.rowChanger.insertRow(this.row);
            }
            ++this.rowCount;
            if (b2) {
                this.dd = languageConnectionContext.getDataDictionary();
                this.td = this.dd.getTableDescriptor(this.constants.targetUUID);
                int maxColumnID;
                int n;
                for (maxColumnID = this.td.getMaxColumnID(), n = 1; n <= maxColumnID && !this.td.getColumnDescriptor(n).isAutoincrement(); ++n) {}
                if (n <= maxColumnID) {
                    long1 = this.row.cloneColumn(n).getLong();
                }
            }
            if (this.constants.singleRowSource) {
                this.row = null;
            }
            else {
                this.row = this.getNextRowCore(this.sourceResultSet);
            }
        }
        if (this.constants.deferred) {
            if (this.triggerInfo != null) {
                Vector<AutoincrementCounter> vector = null;
                if (this.aiCache != null) {
                    vector = new Vector<AutoincrementCounter>();
                    for (int j = 0; j < this.aiCache.length; ++j) {
                        if (this.aiCache[j] != null) {
                            final String schemaName = this.constants.getSchemaName();
                            final String tableName = this.constants.getTableName();
                            final String columnName = this.constants.getColumnName(j);
                            vector.addElement(new AutoincrementCounter(languageConnectionContext.lastAutoincrementValue(schemaName, tableName, columnName), this.constants.getAutoincIncrement(j), this.aiCache[j].getLong(), schemaName, tableName, columnName, j + 1));
                        }
                    }
                }
                if (this.triggerActivator == null) {
                    this.triggerActivator = new TriggerEventActivator(languageConnectionContext, this.tc, this.constants.targetUUID, this.triggerInfo, 3, this.activation, vector);
                }
                else {
                    this.triggerActivator.reopen();
                }
                this.triggerActivator.notifyEvent(TriggerEvents.BEFORE_INSERT, null, this.rowHolder.getResultSet(), null);
            }
            final CursorResultSet resultSet = this.rowHolder.getResultSet();
            try {
                resultSet.open();
                ExecRow nextRow;
                while ((nextRow = resultSet.getNextRow()) != null) {
                    this.sourceResultSet.setCurrentRow(nextRow);
                    this.evaluateCheckConstraints();
                    this.rowChanger.insertRow(nextRow);
                }
            }
            finally {
                this.sourceResultSet.clearCurrentRow();
                resultSet.close();
            }
            if (this.fkChecker != null) {
                final CursorResultSet resultSet2 = this.rowHolder.getResultSet();
                try {
                    resultSet2.open();
                    ExecRow nextRow2;
                    while ((nextRow2 = resultSet2.getNextRow()) != null) {
                        this.fkChecker.doFKCheck(nextRow2);
                    }
                }
                finally {
                    resultSet2.close();
                }
            }
            if (this.triggerActivator != null) {
                this.triggerActivator.notifyEvent(TriggerEvents.AFTER_INSERT, null, this.rowHolder.getResultSet(), null);
            }
        }
        if (this.rowHolder != null) {
            this.rowHolder.close();
        }
        if (this.fkChecker != null) {
            this.fkChecker.close();
            this.fkChecker = null;
        }
        if (this.setIdentity) {
            languageConnectionContext.setIdentityValue(this.identityVal);
        }
        else if (b2) {
            languageConnectionContext.setIdentityValue(long1);
        }
    }
    
    private ExecRow getCompactRow(final ExecRow execRow, final int[] array) throws StandardException {
        final int nColumns = execRow.nColumns();
        if (array == null) {
            final ValueRow valueRow = new ValueRow(nColumns);
            final DataValueDescriptor[] rowArray = execRow.getRowArray();
            System.arraycopy(rowArray, 0, valueRow.getRowArray(), 0, rowArray.length);
            return valueRow;
        }
        final int length = array.length;
        final ValueRow valueRow2 = new ValueRow(length);
        for (int i = 0; i < length; ++i) {
            valueRow2.setColumn(i + 1, execRow.getColumn(array[i]));
        }
        return valueRow2;
    }
    
    private long bulkInsertCore(final LanguageConnectionContext languageConnectionContext, final ExecRow execRow, final long n) throws StandardException {
        this.bulkHeapCC = this.tc.openCompiledConglomerate(false, 4, 7, 5, this.constants.heapSCOCI, this.heapDCOCI);
        final Properties properties = new Properties();
        this.bulkHeapCC.getInternalTablePropertySet(properties);
        if (this.triggerInfo != null) {
            this.triggerActivator = new TriggerEventActivator(languageConnectionContext, this.tc, this.constants.targetUUID, this.triggerInfo, 3, this.activation, null);
        }
        if (this.hasBeforeRowTrigger && this.rowHolder != null) {
            this.rowHolder = new TemporaryRowHolderImpl(this.activation, properties, this.resultDescription);
        }
        final Properties targetProperties = this.constants.getTargetProperties();
        final Enumeration<Object> keys = targetProperties.keys();
        while (keys.hasMoreElements()) {
            final String s = keys.nextElement();
            properties.put(s, targetProperties.getProperty(s));
        }
        if (this.constants.irgs.length > 0) {
            this.sourceResultSet.setNeedsRowLocation(true);
        }
        this.dd = languageConnectionContext.getDataDictionary();
        this.td = this.dd.getTableDescriptor(this.constants.targetUUID);
        final long[] array = { 0L };
        long estimatedRowCount;
        if (this.bulkInsertReplace) {
            estimatedRowCount = this.tc.createAndLoadConglomerate("heap", execRow.getRowArray(), null, this.td.getColumnCollationIds(), properties, 0, this.sourceResultSet, array);
        }
        else {
            estimatedRowCount = this.tc.recreateAndLoadConglomerate("heap", false, execRow.getRowArray(), null, this.td.getColumnCollationIds(), properties, 0, n, this.sourceResultSet, array);
        }
        if (estimatedRowCount == n) {
            return n;
        }
        this.rowCount = array[0];
        this.setEstimatedRowCount(estimatedRowCount);
        this.dd.startWriting(languageConnectionContext);
        languageConnectionContext.autoincrementFlushCache(this.constants.targetUUID);
        this.dd.getDependencyManager().invalidateFor(this.td, 15, languageConnectionContext);
        if (this.constants.irgs.length > 0) {
            this.updateAllIndexes(estimatedRowCount, this.constants, this.td, this.dd, execRow);
        }
        this.bulkHeapCC.close();
        this.bulkHeapCC = null;
        this.dd.updateConglomerateDescriptor(this.td.getConglomerateDescriptor(n), estimatedRowCount, this.tc);
        this.tc.dropConglomerate(n);
        return estimatedRowCount;
    }
    
    private void bulkValidateForeignKeys(final TransactionController transactionController, final ContextManager contextManager, final ExecRow execRow) throws StandardException {
        if ((this.indexRows == null && !this.bulkInsertReplace) || this.fkInfoArray == null) {
            return;
        }
        for (int i = 0; i < this.fkInfoArray.length; ++i) {
            final FKInfo fkInfo = this.fkInfoArray[i];
            if (this.bulkInsertReplace) {
                for (int j = 0; j < fkInfo.fkConglomNumbers.length; ++j) {
                    if (!fkInfo.fkIsSelfReferencing[j] || this.indexRows != null) {
                        long n;
                        long n2;
                        if (fkInfo.fkIsSelfReferencing[j]) {
                            n = this.indexConversionTable.get(new Long(fkInfo.refConglomNumber));
                            n2 = this.indexConversionTable.get(new Long(fkInfo.fkConglomNumbers[j]));
                        }
                        else {
                            final Long n3 = this.indexConversionTable.get(new Long(fkInfo.refConglomNumber));
                            final Long n4 = this.indexConversionTable.get(new Long(fkInfo.fkConglomNumbers[j]));
                            if (n3 == null) {
                                n = fkInfo.refConglomNumber;
                            }
                            else {
                                n = n3;
                            }
                            if (n4 == null) {
                                n2 = fkInfo.fkConglomNumbers[j];
                            }
                            else {
                                n2 = n4;
                            }
                        }
                        this.bulkValidateForeignKeysCore(transactionController, contextManager, this.fkInfoArray[i], n2, n, fkInfo.fkConstraintNames[j], execRow);
                    }
                }
            }
            else {
                this.bulkValidateForeignKeysCore(transactionController, contextManager, this.fkInfoArray[i], (long)this.indexConversionTable.get(new Long(fkInfo.fkConglomNumbers[0])), fkInfo.refConglomNumber, fkInfo.fkConstraintNames[0], execRow);
            }
        }
    }
    
    private void bulkValidateForeignKeysCore(final TransactionController transactionController, final ContextManager contextManager, final FKInfo fkInfo, final long n, final long n2, final String s, final ExecRow execRow) throws StandardException {
        GroupFetchScanController openGroupFetchScan = null;
        GroupFetchScanController openGroupFetchScan2 = null;
        try {
            final ExecRow indexTemplate = this.makeIndexTemplate(fkInfo, execRow, contextManager);
            openGroupFetchScan2 = transactionController.openGroupFetchScan(n, false, 0, 7, 2, null, null, 1, null, null, -1);
            openGroupFetchScan = transactionController.openGroupFetchScan(n2, false, 0, (n == n2) ? 7 : 6, 2, null, null, 1, null, null, -1);
            final ExecRow clone = indexTemplate.getClone();
            if (new RIBulkChecker(openGroupFetchScan, openGroupFetchScan2, indexTemplate, true, null, clone).doCheck() > 0) {
                throw StandardException.newException("23503", s, fkInfo.tableName, StatementUtil.typeName(fkInfo.stmtType), RowUtil.toString(clone, 0, fkInfo.colArray.length - 1));
            }
        }
        finally {
            if (openGroupFetchScan2 != null) {
                openGroupFetchScan2.close();
            }
            if (openGroupFetchScan != null) {
                openGroupFetchScan.close();
            }
        }
    }
    
    private ExecRow makeIndexTemplate(final FKInfo fkInfo, final ExecRow execRow, final ContextManager contextManager) throws StandardException {
        final ExecIndexRow emptyIndexRow = RowUtil.getEmptyIndexRow(fkInfo.colArray.length + 1, this.lcc);
        final DataValueDescriptor[] rowArray = execRow.getRowArray();
        final DataValueDescriptor[] rowArray2 = emptyIndexRow.getRowArray();
        int i;
        for (i = 0; i < fkInfo.colArray.length; ++i) {
            rowArray2[i] = rowArray[fkInfo.colArray[i] - 1].cloneValue(false);
        }
        rowArray2[i] = fkInfo.rowLocation.cloneValue(false);
        return emptyIndexRow;
    }
    
    private void setUpAllSorts(final ExecRow execRow, final RowLocation rowLocation) throws StandardException {
        final int length = this.constants.irgs.length;
        final int numberOfColumns = this.td.getNumberOfColumns();
        this.ordering = new ColumnOrdering[length][];
        this.collation = new int[length][];
        this.needToDropSort = new boolean[length];
        this.sortIds = new long[length];
        this.rowSources = new RowLocationRetRowSource[length];
        this.indexedCols = new FormatableBitSet(numberOfColumns + 1);
        for (int i = 0; i < length; ++i) {
            final int[] baseColumnPositions = this.constants.irgs[i].baseColumnPositions();
            for (int j = 0; j < baseColumnPositions.length; ++j) {
                this.indexedCols.set(baseColumnPositions[j]);
            }
            this.indexRows[i] = this.constants.irgs[i].getIndexRowTemplate();
            this.constants.irgs[i].getIndexRow(execRow, rowLocation, this.indexRows[i], null);
            final ConglomerateDescriptor conglomerateDescriptor = this.td.getConglomerateDescriptor(this.constants.indexCIDS[i]);
            final int[] baseColumnPositions2 = this.constants.irgs[i].baseColumnPositions();
            final boolean[] ascending = this.constants.irgs[i].isAscending();
            final boolean b = length == 1;
            final IndexRowGenerator indexDescriptor = conglomerateDescriptor.getIndexDescriptor();
            final String conglomerateName = conglomerateDescriptor.getConglomerateName();
            Properties properties = null;
            int n;
            BasicSortObserver basicSortObserver;
            if (indexDescriptor.isUnique()) {
                n = (indexDescriptor.isUnique() ? baseColumnPositions2.length : (baseColumnPositions2.length + 1));
                basicSortObserver = new UniqueIndexSortObserver(false, conglomerateDescriptor.isConstraint(), conglomerateName, this.indexRows[i], b, this.td.getName());
            }
            else if (indexDescriptor.isUniqueWithDuplicateNulls()) {
                n = baseColumnPositions2.length + 1;
                properties = new Properties();
                properties.put("implType", "sort almost unique external");
                basicSortObserver = new UniqueWithDuplicateNullsIndexSortObserver(false, conglomerateDescriptor.isConstraint(), conglomerateName, this.indexRows[i], b, this.td.getName());
            }
            else {
                n = baseColumnPositions2.length + 1;
                basicSortObserver = new BasicSortObserver(false, false, this.indexRows[i], b);
            }
            this.ordering[i] = new ColumnOrdering[n];
            for (int k = 0; k < ascending.length; ++k) {
                this.ordering[i][k] = new IndexColumnOrder(k, ascending[k]);
            }
            if (n > ascending.length) {
                this.ordering[i][ascending.length] = new IndexColumnOrder(ascending.length);
            }
            this.collation[i] = this.constants.irgs[i].getColumnCollationIds(this.td.getColumnDescriptorList());
            this.sortIds[i] = this.tc.createSort(properties, this.indexRows[i].getRowArrayClone(), this.ordering[i], basicSortObserver, false, (int)this.sourceResultSet.getEstimatedRowCount(), -1);
            this.needToDropSort[i] = true;
        }
        this.sorters = new SortController[length];
        for (int l = 0; l < length; ++l) {
            this.sorters[l] = this.tc.openSort(this.sortIds[l]);
            this.needToDropSort[l] = true;
        }
    }
    
    private void updateAllIndexes(final long i, final InsertConstantAction insertConstantAction, final TableDescriptor tableDescriptor, final DataDictionary dataDictionary, final ExecRow execRow) throws StandardException {
        final int length = insertConstantAction.irgs.length;
        if (this.indexRows == null) {
            if (this.bulkInsertReplace) {
                this.emptyIndexes(i, insertConstantAction, tableDescriptor, dataDictionary, execRow);
            }
            return;
        }
        dataDictionary.dropStatisticsDescriptors(tableDescriptor.getUUID(), null, this.tc);
        final long[] array = new long[length];
        this.indexConversionTable = new Hashtable(length);
        for (int j = 0; j < length; ++j) {
            final Properties properties = new Properties();
            final ConglomerateDescriptor conglomerateDescriptor = tableDescriptor.getConglomerateDescriptor(insertConstantAction.indexCIDS[j]);
            final ConglomerateController openCompiledConglomerate = this.tc.openCompiledConglomerate(false, 4, 7, 5, insertConstantAction.indexSCOCIs[j], this.indexDCOCIs[j]);
            openCompiledConglomerate.getInternalTablePropertySet(properties);
            final int nColumns = this.indexRows[j].nColumns();
            properties.put("baseConglomerateId", Long.toString(i));
            if (conglomerateDescriptor.getIndexDescriptor().isUnique()) {
                properties.put("nUniqueColumns", Integer.toString(nColumns - 1));
            }
            else {
                properties.put("nUniqueColumns", Integer.toString(nColumns));
            }
            if (conglomerateDescriptor.getIndexDescriptor().isUniqueWithDuplicateNulls()) {
                properties.put("uniqueWithDuplicateNulls", Boolean.toString(true));
            }
            properties.put("rowLocationColumn", Integer.toString(nColumns - 1));
            properties.put("nKeyFields", Integer.toString(nColumns));
            openCompiledConglomerate.close();
            this.sorters[j].completedInserts();
            this.sorters[j] = null;
            this.rowSources[j] = new CardinalityCounter(this.tc.openSortRowSource(this.sortIds[j]));
            array[j] = this.tc.createAndLoadConglomerate("BTREE", this.indexRows[j].getRowArray(), this.ordering[j], this.collation[j], properties, 0, this.rowSources[j], null);
            final CardinalityCounter cardinalityCounter = (CardinalityCounter)this.rowSources[j];
            final long rowCount;
            if ((rowCount = cardinalityCounter.getRowCount()) > 0L) {
                final long[] cardinality = cardinalityCounter.getCardinality();
                for (int k = 0; k < cardinality.length; ++k) {
                    dataDictionary.addDescriptor(new StatisticsDescriptor(dataDictionary, dataDictionary.getUUIDFactory().createUUID(), conglomerateDescriptor.getUUID(), tableDescriptor.getUUID(), "I", new StatisticsImpl(rowCount, cardinality[k]), k + 1), null, 14, true, this.tc);
                }
            }
            dataDictionary.updateConglomerateDescriptor(tableDescriptor.getConglomerateDescriptors(insertConstantAction.indexCIDS[j]), array[j], this.tc);
            this.tc.dropConglomerate(insertConstantAction.indexCIDS[j]);
            this.indexConversionTable.put(new Long(insertConstantAction.indexCIDS[j]), new Long(array[j]));
        }
    }
    
    public void cleanUp() throws StandardException {
        if (this.tableScan != null) {
            this.tableScan.close();
            this.tableScan = null;
        }
        if (this.triggerActivator != null) {
            this.triggerActivator.cleanup();
        }
        if (this.sourceResultSet != null) {
            this.sourceResultSet.close();
        }
        this.numOpens = 0;
        if (this.rowChanger != null) {
            this.rowChanger.close();
        }
        if (this.rowHolder != null) {
            this.rowHolder.close();
        }
        if (this.fkChecker != null) {
            this.fkChecker.close();
        }
        if (this.bulkHeapCC != null) {
            this.bulkHeapCC.close();
            this.bulkHeapCC = null;
        }
        if (this.bulkHeapSC != null) {
            this.bulkHeapSC.close();
            this.bulkHeapSC = null;
        }
        if (this.sorters != null) {
            for (int i = 0; i < this.constants.irgs.length; ++i) {
                if (this.sorters[i] != null) {
                    this.sorters[i].completedInserts();
                }
                this.sorters[i] = null;
            }
        }
        if (this.needToDropSort != null) {
            for (int j = 0; j < this.needToDropSort.length; ++j) {
                if (this.needToDropSort[j]) {
                    this.tc.dropSort(this.sortIds[j]);
                    this.needToDropSort[j] = false;
                }
            }
        }
        if (this.rowSources != null) {
            for (int k = 0; k < this.rowSources.length; ++k) {
                if (this.rowSources[k] != null) {
                    this.rowSources[k].closeRowSource();
                    this.rowSources[k] = null;
                }
            }
        }
        super.close();
    }
    
    protected boolean verifyBulkInsert() throws StandardException {
        return !this.constants.deferred && this.getExclusiveTableLock();
    }
    
    private boolean getExclusiveTableLock() throws StandardException {
        boolean next = false;
        this.bulkHeapSC = this.tc.openCompiledScan(false, 4, 7, 5, null, null, 0, null, null, 0, this.constants.heapSCOCI, this.heapDCOCI);
        if (!this.bulkInsertReplace) {
            next = this.bulkHeapSC.next();
        }
        else {
            this.rl = this.bulkHeapSC.newRowLocationTemplate();
        }
        this.bulkHeapSC.close();
        this.bulkHeapSC = null;
        return !next;
    }
    
    private void setEstimatedRowCount(final long n) throws StandardException {
        (this.bulkHeapSC = this.tc.openCompiledScan(false, 4, 7, 5, null, null, 0, null, null, 0, this.constants.heapSCOCI, this.heapDCOCI)).setEstimatedRowCount(this.rowCount);
        this.bulkHeapSC.close();
        this.bulkHeapSC = null;
    }
    
    private void emptyIndexes(final long i, final InsertConstantAction insertConstantAction, final TableDescriptor tableDescriptor, final DataDictionary dataDictionary, final ExecRow execRow) throws StandardException {
        final int length = insertConstantAction.irgs.length;
        final ExecIndexRow[] array = new ExecIndexRow[length];
        final ColumnOrdering[][] array2 = new ColumnOrdering[length][];
        final int numberOfColumns = tableDescriptor.getNumberOfColumns();
        this.collation = new int[length][];
        final FormatableBitSet set = new FormatableBitSet(numberOfColumns + 1);
        int n = 0;
        for (int j = 0; j < length; ++j) {
            final int[] baseColumnPositions = insertConstantAction.irgs[j].baseColumnPositions();
            for (int k = 0; k < baseColumnPositions.length; ++k) {
                if (!set.get(baseColumnPositions[k])) {
                    set.set(baseColumnPositions[k]);
                    ++n;
                }
            }
        }
        final ExecRow valueRow = this.activation.getExecutionFactory().getValueRow(n);
        int n2 = 0;
        for (int l = 0; l < numberOfColumns; ++l) {
            if (set.get(l + 1)) {
                ++n2;
                valueRow.setColumn(n2, execRow.getColumn(l + 1).cloneValue(false));
            }
        }
        this.needToDropSort = new boolean[length];
        this.sortIds = new long[length];
        for (int n3 = 0; n3 < length; ++n3) {
            array[n3] = insertConstantAction.irgs[n3].getIndexRowTemplate();
            insertConstantAction.irgs[n3].getIndexRow(valueRow, this.rl, array[n3], set);
            final ConglomerateDescriptor conglomerateDescriptor = tableDescriptor.getConglomerateDescriptor(insertConstantAction.indexCIDS[n3]);
            final int[] baseColumnPositions2 = insertConstantAction.irgs[n3].baseColumnPositions();
            final boolean[] ascending = insertConstantAction.irgs[n3].isAscending();
            int length2;
            BasicSortObserver basicSortObserver;
            if (conglomerateDescriptor.getIndexDescriptor().isUnique()) {
                length2 = baseColumnPositions2.length;
                this.getColumnNames(baseColumnPositions2);
                String s = conglomerateDescriptor.getConglomerateName();
                if (conglomerateDescriptor.isConstraint()) {
                    s = dataDictionary.getConstraintDescriptor(tableDescriptor, conglomerateDescriptor.getUUID()).getConstraintName();
                }
                basicSortObserver = new UniqueIndexSortObserver(false, conglomerateDescriptor.isConstraint(), s, array[n3], true, tableDescriptor.getName());
            }
            else {
                length2 = baseColumnPositions2.length + 1;
                basicSortObserver = new BasicSortObserver(false, false, array[n3], true);
            }
            array2[n3] = new ColumnOrdering[length2];
            for (int n4 = 0; n4 < ascending.length; ++n4) {
                array2[n3][n4] = new IndexColumnOrder(n4, ascending[n4]);
            }
            if (length2 > ascending.length) {
                array2[n3][ascending.length] = new IndexColumnOrder(ascending.length);
            }
            this.sortIds[n3] = this.tc.createSort(null, array[n3].getRowArrayClone(), array2[n3], basicSortObserver, false, this.rowCount, -1);
            this.needToDropSort[n3] = true;
        }
        this.rowSources = new RowLocationRetRowSource[length];
        final SortController[] array3 = new SortController[length];
        for (int n5 = 0; n5 < length; ++n5) {
            (array3[n5] = this.tc.openSort(this.sortIds[n5])).completedInserts();
            this.rowSources[n5] = this.tc.openSortRowSource(this.sortIds[n5]);
        }
        final long[] array4 = new long[length];
        for (int n6 = 0; n6 < length; ++n6) {
            final Properties properties = new Properties();
            final ConglomerateDescriptor conglomerateDescriptor2 = tableDescriptor.getConglomerateDescriptor(insertConstantAction.indexCIDS[n6]);
            final ConglomerateController openCompiledConglomerate = this.tc.openCompiledConglomerate(false, 4, 7, 5, insertConstantAction.indexSCOCIs[n6], this.indexDCOCIs[n6]);
            openCompiledConglomerate.getInternalTablePropertySet(properties);
            final int nColumns = array[n6].nColumns();
            properties.put("baseConglomerateId", Long.toString(i));
            if (conglomerateDescriptor2.getIndexDescriptor().isUnique()) {
                properties.put("nUniqueColumns", Integer.toString(nColumns - 1));
            }
            else {
                properties.put("nUniqueColumns", Integer.toString(nColumns));
            }
            if (conglomerateDescriptor2.getIndexDescriptor().isUniqueWithDuplicateNulls()) {
                properties.put("uniqueWithDuplicateNulls", Boolean.toString(true));
            }
            properties.put("rowLocationColumn", Integer.toString(nColumns - 1));
            properties.put("nKeyFields", Integer.toString(nColumns));
            openCompiledConglomerate.close();
            this.collation[n6] = insertConstantAction.irgs[n6].getColumnCollationIds(tableDescriptor.getColumnDescriptorList());
            array4[n6] = this.tc.createAndLoadConglomerate("BTREE", array[n6].getRowArray(), null, this.collation[n6], properties, 0, this.rowSources[n6], null);
            dataDictionary.updateConglomerateDescriptor(tableDescriptor.getConglomerateDescriptors(insertConstantAction.indexCIDS[n6]), array4[n6], this.tc);
            this.tc.dropConglomerate(insertConstantAction.indexCIDS[n6]);
        }
    }
    
    private BulkTableScanResultSet getTableScanResultSet(final long n) throws StandardException {
        if (this.tableScan == null) {
            (this.tableScan = new BulkTableScanResultSet(n, this.tc.getStaticCompiledConglomInfo(n), this.activation, this.fullTemplateId, 0, null, 0, null, 0, false, null, "tableName", null, null, false, false, -1, -1, 7, true, 2, 16, false, false, 0.0, 0.0)).openCore();
        }
        else {
            this.tableScan.reopenCore();
        }
        return this.tableScan;
    }
    
    private String[] getColumnNames(final int[] array) {
        final int length = array.length;
        final String[] array2 = new String[length];
        for (int i = 0; i < length; ++i) {
            array2[i] = this.constants.getColumnName(i);
        }
        return array2;
    }
    
    public void finish() throws StandardException {
        this.sourceResultSet.finish();
        super.finish();
    }
}
