// 
// Decompiled by Procyon v0.5.36
// 

package org.apache.hadoop.yarn.webapp.hamlet;

import org.slf4j.LoggerFactory;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.GnuParser;
import org.apache.hadoop.yarn.webapp.WebAppException;
import java.util.Locale;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.Method;
import java.lang.annotation.Annotation;
import java.io.IOException;
import com.google.common.collect.Sets;
import java.util.Set;
import java.io.PrintWriter;
import java.util.regex.Pattern;
import org.apache.commons.cli.Options;
import org.slf4j.Logger;
import org.apache.hadoop.classification.InterfaceAudience;

@InterfaceAudience.LimitedPrivate({ "YARN", "MapReduce" })
public class HamletGen
{
    static final Logger LOG;
    static final Options opts;
    static final Pattern elementRegex;
    int bytes;
    PrintWriter out;
    final Set<String> endTagOptional;
    final Set<String> inlineElements;
    Class<?> top;
    String hamlet;
    boolean topMode;
    
    public HamletGen() {
        this.bytes = 0;
        this.endTagOptional = (Set<String>)Sets.newHashSet();
        this.inlineElements = (Set<String>)Sets.newHashSet();
    }
    
    public void generate(final Class<?> specClass, final Class<?> implClass, final String outputName, final String outputPkg) throws IOException {
        HamletGen.LOG.info("Generating {} using {} and {}", outputName, specClass, implClass);
        this.out = new PrintWriter(outputName + ".java", "UTF-8");
        this.hamlet = this.basename(outputName);
        final String pkg = this.pkgName(outputPkg, implClass.getPackage().getName());
        this.puts(0, "// Generated by HamletGen. Do NOT edit!\n", "package ", pkg, ";\n", "import java.io.PrintWriter;\n", "import java.util.EnumSet;\n", "import static java.util.EnumSet.*;\n", "import static ", implClass.getName(), ".EOpt.*;\n", "import org.apache.hadoop.yarn.webapp.SubView;");
        final String implClassName = implClass.getSimpleName();
        if (!implClass.getPackage().getName().equals(pkg)) {
            this.puts(0, "import ", implClass.getName(), ';');
        }
        this.puts(0, "\n", "public class ", this.hamlet, " extends ", implClassName, " implements ", specClass.getSimpleName(), "._Html {\n", "  public ", this.hamlet, "(PrintWriter out, int nestLevel,", " boolean wasInline) {\n", "    super(out, nestLevel, wasInline);\n", "  }\n\n", "  static EnumSet<EOpt> opt(boolean endTag, boolean inline, ", "boolean pre) {\n", "    EnumSet<EOpt> opts = of(ENDTAG);\n", "    if (!endTag) opts.remove(ENDTAG);\n", "    if (inline) opts.add(INLINE);\n", "    if (pre) opts.add(PRE);\n", "    return opts;\n", "  }");
        this.initLut(specClass);
        this.genImpl(specClass, implClassName, 1);
        HamletGen.LOG.info("Generating {} methods", this.hamlet);
        this.genMethods(this.hamlet, this.top, 1);
        this.puts(0, "}");
        this.out.close();
        HamletGen.LOG.info("Wrote {} bytes to {}.java", (Object)this.bytes, outputName);
    }
    
    String basename(final String path) {
        return path.substring(path.lastIndexOf(47) + 1);
    }
    
    String pkgName(final String pkg, final String defaultPkg) {
        if (pkg == null || pkg.isEmpty()) {
            return defaultPkg;
        }
        return pkg;
    }
    
    void initLut(final Class<?> spec) {
        this.endTagOptional.clear();
        this.inlineElements.clear();
        for (final Class<?> cls : spec.getClasses()) {
            final Annotation a = cls.getAnnotation(HamletSpec.Element.class);
            if (a != null && !((HamletSpec.Element)a).endTag()) {
                this.endTagOptional.add(cls.getSimpleName());
            }
            if (cls.getSimpleName().equals("Inline")) {
                for (final Method method : cls.getMethods()) {
                    final String retName = method.getReturnType().getSimpleName();
                    if (this.isElement(retName)) {
                        this.inlineElements.add(retName);
                    }
                }
            }
        }
    }
    
    void genImpl(final Class<?> spec, final String implClassName, final int indent) {
        final String specName = spec.getSimpleName();
        for (final Class<?> cls : spec.getClasses()) {
            final String className = cls.getSimpleName();
            if (cls.isInterface()) {
                this.genFactoryMethods(cls, indent);
            }
            if (this.isElement(className)) {
                HamletGen.LOG.info("Generating class {}<T>", className);
                this.puts(indent, "\n", "public class ", className, "<T extends _>", " extends EImp<T> implements ", specName, ".", className, " {\n", "  public ", className, "(String name, T parent,", " EnumSet<EOpt> opts) {\n", "    super(name, parent, opts);\n", "  }");
                this.genMethods(className, cls, indent + 1);
                this.puts(indent, "}");
            }
            else if (className.equals("_Html")) {
                this.top = cls;
            }
        }
    }
    
    void genFactoryMethods(final Class<?> cls, final int indent) {
        for (final Method method : cls.getDeclaredMethods()) {
            final String retName = method.getReturnType().getSimpleName();
            final String methodName = method.getName();
            if (methodName.charAt(0) != '$') {
                if (this.isElement(retName) && method.getParameterTypes().length == 0) {
                    this.genFactoryMethod(retName, methodName, indent);
                }
            }
        }
    }
    
    void genMethods(final String className, final Class<?> cls, final int indent) {
        this.topMode = (this.top != null && cls.equals(this.top));
        for (final Method method : cls.getMethods()) {
            final String retName = method.getReturnType().getSimpleName();
            if (method.getName().charAt(0) == '$') {
                this.genAttributeMethod(className, method, indent);
            }
            else if (this.isElement(retName)) {
                this.genNewElementMethod(className, method, indent);
            }
            else {
                this.genCurElementMethod(className, method, indent);
            }
        }
    }
    
    void genAttributeMethod(final String className, final Method method, final int indent) {
        final String methodName = method.getName();
        final String attrName = methodName.substring(1).replace('_', '-');
        final Type[] params = method.getGenericParameterTypes();
        this.echo(indent, "\n", "@Override\n", "public ", className, this.topMode ? " " : "<T> ", methodName, "(");
        if (params.length == 0) {
            this.puts(0, ") {");
            this.puts(indent, "  addAttr(\"", attrName, "\", null);\n", "  return this;\n", "}");
        }
        else if (params.length == 1) {
            final String typeName = this.getTypeName(params[0]);
            this.puts(0, typeName, " value) {");
            if (typeName.equals("EnumSet<LinkType>")) {
                this.puts(indent, "  addRelAttr(\"", attrName, "\", value);\n", "  return this;\n", "}");
            }
            else if (typeName.equals("EnumSet<Media>")) {
                this.puts(indent, "  addMediaAttr(\"", attrName, "\", value);\n", "  return this;\n", "}");
            }
            else {
                this.puts(indent, "  addAttr(\"", attrName, "\", value);\n", "  return this;\n", "}");
            }
        }
        else {
            throwUnhandled(className, method);
        }
    }
    
    String getTypeName(final Type type) {
        if (type instanceof Class) {
            return ((Class)type).getSimpleName();
        }
        final ParameterizedType pt = (ParameterizedType)type;
        return ((Class)pt.getRawType()).getSimpleName() + "<" + ((Class)pt.getActualTypeArguments()[0]).getSimpleName() + ">";
    }
    
    void genFactoryMethod(final String retName, final String methodName, final int indent) {
        this.puts(indent, "\n", "private <T extends _> ", retName, "<T> ", methodName, "_(T e, boolean inline) {\n", "  return new ", retName, "<T>(\"", retName.toLowerCase(Locale.US), "\", e, opt(", !this.endTagOptional.contains(retName), ", inline, ", retName.equals("PRE"), ")); }");
    }
    
    void genNewElementMethod(final String className, final Method method, final int indent) {
        final String methodName = method.getName();
        final String retName = method.getReturnType().getSimpleName();
        final Class<?>[] params = method.getParameterTypes();
        this.echo(indent, "\n", "@Override\n", "public ", retName, "<", className, this.topMode ? "> " : "<T>> ", methodName, "(");
        if (params.length == 0) {
            this.puts(0, ") {");
            this.puts(indent, this.topMode ? "" : "  closeAttrs();\n", "  return ", retName.toLowerCase(Locale.US), "_(this, ", this.isInline(className, retName), ");\n", "}");
        }
        else if (params.length == 1) {
            this.puts(0, "String selector) {");
            this.puts(indent, "  return setSelector(", methodName, "(), selector);\n", "}");
        }
        else {
            throwUnhandled(className, method);
        }
    }
    
    boolean isInline(final String container, final String className) {
        return ((!container.equals("BODY") && !container.equals(this.hamlet) && !container.equals("HEAD") && !container.equals("HTML")) || (!className.equals("INS") && !className.equals("DEL") && !className.equals("SCRIPT"))) && this.inlineElements.contains(className);
    }
    
    void genCurElementMethod(final String className, final Method method, final int indent) {
        final String methodName = method.getName();
        final Class<?>[] params = method.getParameterTypes();
        if (this.topMode || params.length > 0) {
            this.echo(indent, "\n", "@Override\n", "public ", className, this.topMode ? " " : "<T> ", methodName, "(");
        }
        if (params.length == 0) {
            if (this.topMode) {
                this.puts(0, ") {");
                this.puts(indent, "  return this;\n", "}");
            }
        }
        else if (params.length == 1) {
            if (methodName.equals("base")) {
                this.puts(0, "String href) {");
                this.puts(indent, "  return base().$href(href)._();\n", "}");
            }
            else if (methodName.equals("script")) {
                this.puts(0, "String src) {");
                this.puts(indent, "  return setScriptSrc(script(), src)._();\n", "}");
            }
            else if (methodName.equals("style")) {
                this.puts(0, "Object... lines) {");
                this.puts(indent, "  return style().$type(\"text/css\")._(lines)._();\n", "}");
            }
            else if (methodName.equals("img")) {
                this.puts(0, "String src) {");
                this.puts(indent, "  return ", methodName, "().$src(src)._();\n", "}");
            }
            else if (methodName.equals("br") || methodName.equals("hr") || methodName.equals("col")) {
                this.puts(0, "String selector) {");
                this.puts(indent, "  return setSelector(", methodName, "(), selector)._();\n", "}");
            }
            else if (methodName.equals("link")) {
                this.puts(0, "String href) {");
                this.puts(indent, "  return setLinkHref(", methodName, "(), href)._();\n", "}");
            }
            else if (methodName.equals("_")) {
                if (params[0].getSimpleName().equals("Class")) {
                    this.puts(0, "Class<? extends SubView> cls) {");
                    this.puts(indent, "  ", this.topMode ? "subView" : "_v", "(cls);\n", "  return this;\n", "}");
                }
                else {
                    this.puts(0, "Object... lines) {");
                    this.puts(indent, "  _p(", needsEscaping(className), ", lines);\n", "  return this;\n", "}");
                }
            }
            else if (methodName.equals("_r")) {
                this.puts(0, "Object... lines) {");
                this.puts(indent, "  _p(false, lines);\n", "  return this;\n", "}");
            }
            else {
                this.puts(0, "String cdata) {");
                this.puts(indent, "  return ", methodName, "()._(cdata)._();\n", "}");
            }
        }
        else if (params.length == 2) {
            if (methodName.equals("meta")) {
                this.puts(0, "String name, String content) {");
                this.puts(indent, "  return meta().$name(name).$content(content)._();\n", "}");
            }
            else if (methodName.equals("meta_http")) {
                this.puts(0, "String header, String content) {");
                this.puts(indent, "  return meta().$http_equiv(header).$content(content)._();\n", "}");
            }
            else if (methodName.equals("a")) {
                this.puts(0, "String href, String anchorText) {");
                this.puts(indent, "  return a().$href(href)._(anchorText)._();\n", "}");
            }
            else if (methodName.equals("bdo")) {
                this.puts(0, "Dir dir, String cdata) {");
                this.puts(indent, "  return bdo().$dir(dir)._(cdata)._();\n", "}");
            }
            else if (methodName.equals("label")) {
                this.puts(0, "String forId, String cdata) {");
                this.puts(indent, "  return label().$for(forId)._(cdata)._();\n", "}");
            }
            else if (methodName.equals("param")) {
                this.puts(0, "String name, String value) {");
                this.puts(indent, "  return param().$name(name).$value(value)._();\n", "}");
            }
            else {
                this.puts(0, "String selector, String cdata) {");
                this.puts(indent, "  return setSelector(", methodName, "(), selector)._(cdata)._();\n", "}");
            }
        }
        else if (params.length == 3) {
            if (methodName.equals("a")) {
                this.puts(0, "String selector, String href, String anchorText) {");
                this.puts(indent, "  return setSelector(a(), selector)", ".$href(href)._(anchorText)._();\n", "}");
            }
        }
        else {
            throwUnhandled(className, method);
        }
    }
    
    static boolean needsEscaping(final String eleName) {
        return !eleName.equals("SCRIPT") && !eleName.equals("STYLE");
    }
    
    static void throwUnhandled(final String className, final Method method) {
        throw new WebAppException("Unhandled " + className + "#" + method);
    }
    
    void echo(final int indent, final Object... args) {
        String prev = null;
        for (final Object o : args) {
            final String s = String.valueOf(o);
            if (!s.isEmpty() && !s.equals("\n") && (prev == null || prev.endsWith("\n"))) {
                this.indent(indent);
            }
            prev = s;
            this.out.print(s);
            this.bytes += s.length();
        }
    }
    
    void indent(final int indent) {
        for (int i = 0; i < indent; ++i) {
            this.out.print("  ");
            this.bytes += 2;
        }
    }
    
    void puts(final int indent, final Object... args) {
        this.echo(indent, args);
        this.out.println();
        ++this.bytes;
    }
    
    boolean isElement(final String s) {
        return HamletGen.elementRegex.matcher(s).matches();
    }
    
    public static void main(final String[] args) throws Exception {
        final CommandLine cmd = new GnuParser().parse(HamletGen.opts, args);
        if (cmd.hasOption("help")) {
            new HelpFormatter().printHelp("Usage: hbgen [OPTIONS]", HamletGen.opts);
            return;
        }
        Class<?> specClass = HamletSpec.class;
        Class<?> implClass = HamletImpl.class;
        String outputClass = "HamletTmp";
        String outputPackage = implClass.getPackage().getName();
        if (cmd.hasOption("spec-class")) {
            specClass = Class.forName(cmd.getOptionValue("spec-class"));
        }
        if (cmd.hasOption("impl-class")) {
            implClass = Class.forName(cmd.getOptionValue("impl-class"));
        }
        if (cmd.hasOption("output-class")) {
            outputClass = cmd.getOptionValue("output-class");
        }
        if (cmd.hasOption("output-package")) {
            outputPackage = cmd.getOptionValue("output-package");
        }
        new HamletGen().generate(specClass, implClass, outputClass, outputPackage);
    }
    
    static {
        LOG = LoggerFactory.getLogger(HamletGen.class);
        opts = new Options();
        HamletGen.opts.addOption("h", "help", false, "Print this help message").addOption("s", "spec-class", true, "The class that holds the spec interfaces. e.g. HamletSpec").addOption("i", "impl-class", true, "An implementation class. e.g. HamletImpl").addOption("o", "output-class", true, "Output class name").addOption("p", "output-package", true, "Output package name");
        elementRegex = Pattern.compile("^[A-Z][A-Z0-9]*$");
    }
}
