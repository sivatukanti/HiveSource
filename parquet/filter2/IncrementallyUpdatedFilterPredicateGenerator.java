// 
// Decompiled by Procyon v0.5.36
// 

package parquet.filter2;

import java.io.IOException;
import java.io.File;
import java.io.FileWriter;

public class IncrementallyUpdatedFilterPredicateGenerator
{
    private final FileWriter writer;
    private static final TypeInfo[] TYPES;
    
    public static void main(final String[] args) throws IOException {
        File srcFile = new File(args[0] + "/parquet/filter2/recordlevel/IncrementallyUpdatedFilterPredicateBuilder.java");
        srcFile = srcFile.getAbsoluteFile();
        final File parent = srcFile.getParentFile();
        if (!parent.exists() && !parent.mkdirs()) {
            throw new IOException("Couldn't mkdirs for " + parent);
        }
        new IncrementallyUpdatedFilterPredicateGenerator(srcFile).run();
    }
    
    public IncrementallyUpdatedFilterPredicateGenerator(final File file) throws IOException {
        this.writer = new FileWriter(file);
    }
    
    public void run() throws IOException {
        this.add("package parquet.filter2.recordlevel;\n\nimport parquet.hadoop.metadata.ColumnPath;\nimport parquet.filter2.predicate.Operators.Eq;\nimport parquet.filter2.predicate.Operators.Gt;\nimport parquet.filter2.predicate.Operators.GtEq;\nimport parquet.filter2.predicate.Operators.LogicalNotUserDefined;\nimport parquet.filter2.predicate.Operators.Lt;\nimport parquet.filter2.predicate.Operators.LtEq;\nimport parquet.filter2.predicate.Operators.NotEq;\nimport parquet.filter2.predicate.Operators.UserDefined;\nimport parquet.filter2.predicate.UserDefinedPredicate;\nimport parquet.filter2.recordlevel.IncrementallyUpdatedFilterPredicate.ValueInspector;\nimport parquet.io.api.Binary;\n\n/**\n * This class is auto-generated by {@link parquet.filter2.IncrementallyUpdatedFilterPredicateGenerator}\n * Do not manually edit!\n * See {@link IncrementallyUpdatedFilterPredicateBuilderBase}\n */\n");
        this.add("public class IncrementallyUpdatedFilterPredicateBuilder extends IncrementallyUpdatedFilterPredicateBuilderBase {\n\n");
        this.addVisitBegin("Eq");
        for (final TypeInfo info : IncrementallyUpdatedFilterPredicateGenerator.TYPES) {
            this.addEqNotEqCase(info, true);
        }
        this.addVisitEnd();
        this.addVisitBegin("NotEq");
        for (final TypeInfo info : IncrementallyUpdatedFilterPredicateGenerator.TYPES) {
            this.addEqNotEqCase(info, false);
        }
        this.addVisitEnd();
        this.addVisitBegin("Lt");
        for (final TypeInfo info : IncrementallyUpdatedFilterPredicateGenerator.TYPES) {
            this.addInequalityCase(info, "<");
        }
        this.addVisitEnd();
        this.addVisitBegin("LtEq");
        for (final TypeInfo info : IncrementallyUpdatedFilterPredicateGenerator.TYPES) {
            this.addInequalityCase(info, "<=");
        }
        this.addVisitEnd();
        this.addVisitBegin("Gt");
        for (final TypeInfo info : IncrementallyUpdatedFilterPredicateGenerator.TYPES) {
            this.addInequalityCase(info, ">");
        }
        this.addVisitEnd();
        this.addVisitBegin("GtEq");
        for (final TypeInfo info : IncrementallyUpdatedFilterPredicateGenerator.TYPES) {
            this.addInequalityCase(info, ">=");
        }
        this.addVisitEnd();
        this.add("  @Override\n  public <T extends Comparable<T>, U extends UserDefinedPredicate<T>> IncrementallyUpdatedFilterPredicate visit(UserDefined<T, U> pred) {\n");
        this.addUdpBegin();
        for (final TypeInfo info : IncrementallyUpdatedFilterPredicateGenerator.TYPES) {
            this.addUdpCase(info, false);
        }
        this.addVisitEnd();
        this.add("  @Override\n  public <T extends Comparable<T>, U extends UserDefinedPredicate<T>> IncrementallyUpdatedFilterPredicate visit(LogicalNotUserDefined<T, U> notPred) {\n    UserDefined<T, U> pred = notPred.getUserDefined();\n");
        this.addUdpBegin();
        for (final TypeInfo info : IncrementallyUpdatedFilterPredicateGenerator.TYPES) {
            this.addUdpCase(info, true);
        }
        this.addVisitEnd();
        this.add("}\n");
        this.writer.close();
    }
    
    private void addVisitBegin(final String inVar) throws IOException {
        this.add("  @Override\n  public <T extends Comparable<T>> IncrementallyUpdatedFilterPredicate visit(" + inVar + "<T> pred) {\n" + "    ColumnPath columnPath = pred.getColumn().getColumnPath();\n" + "    Class<T> clazz = pred.getColumn().getColumnType();\n" + "\n" + "    ValueInspector valueInspector = null;\n\n");
    }
    
    private void addVisitEnd() throws IOException {
        this.add("    if (valueInspector == null) {\n      throw new IllegalArgumentException(\"Encountered unknown type \" + clazz);\n    }\n\n    addValueInspector(columnPath, valueInspector);\n    return valueInspector;\n  }\n\n");
    }
    
    private void addEqNotEqCase(final TypeInfo info, final boolean isEq) throws IOException {
        this.add("    if (clazz.equals(" + info.className + ".class)) {\n" + "      if (pred.getValue() == null) {\n" + "        valueInspector = new ValueInspector() {\n" + "          @Override\n" + "          public void updateNull() {\n" + "            setResult(" + isEq + ");\n" + "          }\n" + "\n" + "          @Override\n" + "          public void update(" + info.primitiveName + " value) {\n" + "            setResult(" + !isEq + ");\n" + "          }\n" + "        };\n" + "      } else {\n" + "        final " + info.primitiveName + " target = (" + info.className + ") (Object) pred.getValue();\n" + "\n" + "        valueInspector = new ValueInspector() {\n" + "          @Override\n" + "          public void updateNull() {\n" + "            setResult(" + !isEq + ");\n" + "          }\n" + "\n" + "          @Override\n" + "          public void update(" + info.primitiveName + " value) {\n");
        if (info.useComparable) {
            this.add("            setResult(" + this.compareEquality("value", "target", isEq) + ");\n");
        }
        else {
            this.add("            setResult(" + (isEq ? "value == target" : "value != target") + ");\n");
        }
        this.add("          }\n        };\n      }\n    }\n\n");
    }
    
    private void addInequalityCase(final TypeInfo info, final String op) throws IOException {
        if (!info.supportsInequality) {
            this.add("    if (clazz.equals(" + info.className + ".class)) {\n");
            this.add("      throw new IllegalArgumentException(\"Operator " + op + " not supported for " + info.className + "\");\n");
            this.add("    }\n\n");
            return;
        }
        this.add("    if (clazz.equals(" + info.className + ".class)) {\n" + "      final " + info.primitiveName + " target = (" + info.className + ") (Object) pred.getValue();\n" + "\n" + "      valueInspector = new ValueInspector() {\n" + "        @Override\n" + "        public void updateNull() {\n" + "          setResult(false);\n" + "        }\n" + "\n" + "        @Override\n" + "        public void update(" + info.primitiveName + " value) {\n");
        if (info.useComparable) {
            this.add("          setResult(value.compareTo(target) " + op + " 0);\n");
        }
        else {
            this.add("          setResult(value " + op + " target);\n");
        }
        this.add("        }\n      };\n    }\n\n");
    }
    
    private void addUdpBegin() throws IOException {
        this.add("    ColumnPath columnPath = pred.getColumn().getColumnPath();\n    Class<T> clazz = pred.getColumn().getColumnType();\n\n    ValueInspector valueInspector = null;\n\n    final U udp = pred.getUserDefinedPredicate();\n\n");
    }
    
    private void addUdpCase(final TypeInfo info, final boolean invert) throws IOException {
        this.add("    if (clazz.equals(" + info.className + ".class)) {\n" + "      valueInspector = new ValueInspector() {\n" + "        @Override\n" + "        public void updateNull() {\n" + "          setResult(" + (invert ? "!" : "") + "udp.keep(null));\n" + "        }\n" + "\n" + "        @SuppressWarnings(\"unchecked\")\n" + "        @Override\n" + "        public void update(" + info.primitiveName + " value) {\n" + "          setResult(" + (invert ? "!" : "") + "udp.keep((T) (Object) value));\n" + "        }\n" + "      };\n" + "    }\n\n");
    }
    
    private String compareEquality(final String var, final String target, final boolean eq) {
        return var + ".compareTo(" + target + ")" + (eq ? " == 0 " : " != 0");
    }
    
    private void add(final String s) throws IOException {
        this.writer.write(s);
    }
    
    static {
        TYPES = new TypeInfo[] { new TypeInfo("Integer", "int", false, true), new TypeInfo("Long", "long", false, true), new TypeInfo("Boolean", "boolean", false, false), new TypeInfo("Float", "float", false, true), new TypeInfo("Double", "double", false, true), new TypeInfo("Binary", "Binary", true, true) };
    }
    
    private static class TypeInfo
    {
        public final String className;
        public final String primitiveName;
        public final boolean useComparable;
        public final boolean supportsInequality;
        
        private TypeInfo(final String className, final String primitiveName, final boolean useComparable, final boolean supportsInequality) {
            this.className = className;
            this.primitiveName = primitiveName;
            this.useComparable = useComparable;
            this.supportsInequality = supportsInequality;
        }
    }
}
